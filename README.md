# GameJam2025

## Atualizações 26/11/2025

### Correção Passo 1: Removida struct obsoleta – SO como fonte única de config
- Eliminada a struct/classe `PlanetDefenseSpawnConfig`; os runners e o serviço de spawn agora leem diretamente o `DefenseWaveProfileSO` atribuído pelo `PlanetDefenseController`, mantendo o ScriptableObject como única fonte de configuração de ondas.
- O `PlanetDefenseSpawnService` recebe o profile via `SetWaveProfile` (comentado em português para lembrar que SO não é injetado via DI) e registra bindings do `EventBus` após a injeção, garantindo que eventos `Engaged/Disengaged/Disabled` acionem warm-up e start/stop de ondas.
- `RealPlanetDefenseWaveRunner` usa os valores do `DefenseWaveProfileSO` presente no `PlanetDefenseSetupContext` para intervalo e quantidade de spawns, mantendo timers alinhados ao asset configurado no Inspector e evitando valores duplicados em structs.
- Removidos resíduos de referências ao antigo config e corrigido o uso de `PlanetDefenseSetupContext` no runner de waves para evitar variáveis inexistentes em `SpawnWave`.

### Correção Passo 1: Removida injeção DI em SO – configs via Inspector
- ScriptableObjects (`DefenseWaveProfileSO`) deixam de ser injetados via DI e agora são atribuídos diretamente pelo `PlanetDefenseController` usando `SetWaveProfile`, mantendo o Inspector como fonte única de configuração.
- `PlanetDefenseSpawnService` recebe o profile via método público (com aviso explícito em português) e repassa ao `PlanetDefenseSetupContext`, evitando criação dinâmica de assets e mantendo o fluxo controlado por cena.
- Logs verbosos foram adicionados para confirmar o profile atribuído e para alertar quando nenhum profile for fornecido, facilitando depuração de cenas multiplayer locais.

### Correção Passo 1: PoolData não injetado
- Movido o aviso de PoolData ausente para ocorrer somente após a injeção de dependências e configuração do PoolData, garantindo que assets atribuídos no Inspector (ex.: `PoolDataDefenses.asset`) sejam respeitados antes de qualquer log de alerta.
- Adicionados logs verbosos no `PlanetDefenseSpawnService` para registrar o PoolData padrão configurado e o flag `WarmUpPools`, facilitando depuração de cenas onde o serviço é instanciado via código e o PoolData é definido em `PlanetDefenseController`.
- Centralizado o uso do `DefenseWaveProfileSO` como fonte única de configuração das ondas (intervalo, minions, raio/altura) por planeta, compartilhando a mesma instância via DI sem criar ScriptableObjects em runtime.

### Passo 1 — Avaliação e Preparação (Pré-Refatoração)
- **Escopo analisado:** `PlanetDefenseController`, `PlanetDefenseDetectable`, `PlanetDefenseSpawnService`, `PlanetDefenseEvents`, stubs (`NullPlanetDefensePoolRunner`, `NullPlanetDefenseWaveRunner`) e `DefensesMinionData`. Referências externas observadas: `PlanetsMaster`, `PlanetsManager`, `EventBus`, `DetectionSystems`, `PoolSystem`.
- **Fluxo atual mapeado:**
  1. Sensores (`IDetector`) entram em alcance do planeta via `PlanetDefenseDetectable`, que registra a entrada para evitar chamadas duplicadas e aciona `PlanetDefenseController.EngageDefense` com o `DetectionType`.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Detectable/PlanetDefenseDetectable.cs†L32-L78】
  2. `PlanetDefenseController` resolve o papel (`DefenseRole`) do detector, mantém contagem local de detectores ativos e publica `PlanetDefenseEngagedEvent` com flag de primeira ativação e total de detectores. Desengates removem da tabela e publicam `PlanetDefenseDisengagedEvent`; ao desabilitar o objeto, emite `PlanetDefenseDisabledEvent` e limpa estado.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Detectable/PlanetDefenseController.cs†L13-L115】
  3. `PlanetDefenseSpawnService` escuta os três eventos para rastrear estado de defesa por planeta, apenas para logging/debug. Mantém dicionário `PlanetsMaster -> ActiveDefenseState`, registra/atualiza contadores, e em `Update` gera logs periódicos simulando ondas. Não inicia spawns reais e limpa bindings no `OnDisable`.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseSpawnService.cs†L15-L198】【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseSpawnService.cs†L198-L278】
  4. Stubs `NullPlanetDefensePoolRunner` e `NullPlanetDefenseWaveRunner` fornecem fallbacks de DI para pools/ondas, armazenando apenas estado mínimo (`HashSet` de planetas rodando).【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseRunnerStubs.cs†L1-L80】
  5. Dados de minion (`DefensesMinionData`) derivam de `PoolableObjectData` e definem menu de criação, mas não têm lógica adicional.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/DefensesMinionData.cs†L1-L9】

### Dependências identificadas
- **PlanetsMaster**: usado como chave de estado em controlador/spawn service; fornece `ActorName` para logs. Integração com `PlanetsManager` via eventos de morte (potencial ponto de integração futuro).【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Detectable/PlanetDefenseController.cs†L13-L115】【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/PlanetsMaster.cs†L1-L74】
- **EventBus**: transporte principal entre detecção e serviços de defesa; bindings registrados no `OnEnable`/`OnDisable` do spawn service. Sem verificação de duplicidade de registro além de nulidade.
- **DetectionSystems**: `IDetector`, `DetectionType`, `AbstractDetectable` definem contratos de entrada/saída. `PlanetDefenseDetectable` assume um `myDetectionType` herdado.
- **PoolSystem e Wave Runners**: apenas stubs; ausência de implementação real significa que futuras refatorações devem plugar serviços concretos via DI sem quebrar os contratos já usados pelo spawn service.
- **Multiplayer local**: nenhum código atual trata identificação de jogadores múltiplos além de heurísticas de nome em `ResolveDefenseRole` (busca "Player" no nome). Pode gerar ambiguidades em sessões locais com vários players.

### Pontos fracos e riscos
- **Dependência de nomes para papel**: `ResolveDefenseRole` inspeciona strings em `ActorName`, quebrando princípio de fonte única de verdade e tornando o comportamento frágil para multiplayer local (nomes duplicados). Necessário Strategy/Provider formal para papel de defesa.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Detectable/PlanetDefenseController.cs†L62-L108】
- **Acoplamento a logs e Update**: `PlanetDefenseSpawnService` roda em `Update` apenas para debug; ausência de throttling de GC (strings concatenadas) e falta de `StopWavesOnDisable` aplicação real. Quando implementar spawns reais, Update deve considerar escala de tempo e múltiplas instâncias.
- **Lacuna de sincronização**: `OnDisable` de `PlanetDefenseDetectable` força `DisengageDefense` para cada detector registrado, mas o controlador apenas limpa contagem e publica evento em `OnDisable` se ainda houver detectores. Em pipelines rápidos, pode gerar eventos redundantes. Revisar responsabilidade de limpeza única.
- **Ausência de telemetria central**: não há agregador para múltiplos serviços de defesa (pool, ondas, efeitos). EventBus cobre transporte, mas falta um orchestrator aplicando Strategy/DI para cada planeta (ex.: `IPlanetDefenseOrchestrator`).
- **Teste/Debug**: Sem testes automatizados. Interpretação de `DetectionType` como `TypeName` para logs; não há validação de nulos na origem do evento (detector/planeta nulo apenas retorna silenciosamente). Pode mascarar falhas.

### Recomendações para próximos passos
- Introduzir **interfaces claras de papel** (`IDefenseRoleProvider` concreto ou Strategy) e eliminar heurística por nome; permitir binding por jogador local (ex.: inject `IPlayerIdentity`).
- Criar **serviço orquestrador** que reaja aos eventos e coordene runners reais (pool/wave), mantendo `PlanetDefenseSpawnService` apenas para debug ou migrando logs para o orquestrador.
- Substituir uso de `Update` por **timers/Tasks** específicos ou corrotinas encapsuladas por planeta para evitar conflito em multiplayer local e reduzir carga de logs.
- Formalizar **contratos de DI** para `IPlanetDefensePoolRunner`/`IPlanetDefenseWaveRunner`, com configuração por ScriptableObject para cenas locais múltiplas.
- Adicionar **testes de integração** para fluxo de eventos (engage → start waves; disengage → stop) e cenários de desabilitação, garantindo idempotência e contagem correta.

### Passo 2 — Refatorar Interfaces e Abstrações (D/I do SOLID)
- **Interfaces segmentadas de listener**: `IPlanetDefenseActivationListener` agora agrega `IDefenseEngagedListener`, `IDefenseDisengagedListener` e `IDefenseDisabledListener`, permitindo que serviços implementem apenas os eventos necessários, reduzindo acoplamento e favorecendo Interface Segregation. Registrados globalmente no bootstrapper para suportar DI parcial.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseSpawnService.cs†L15-L42】【F:Assets/_ImmersiveGames/Scripts/Utils/DependencySystems/DependencyBootstrapper.cs†L88-L110】
- **Contratos de configuração por planeta**: `IPlanetDefensePoolRunner` e `IPlanetDefenseWaveRunner` ganharam métodos opcionais para configurar minions, recursos e estratégias por planeta (`ConfigureForPlanet`, `TryGetConfiguration`, `WarmUp(PlanetDefenseSetupContext)`, `ConfigureStrategy`, `TryGetStrategy`, `StartWaves` com estratégia), mantendo compatibilidade com chamadas existentes. Os stubs `Null*` armazenam configurações sem executar lógica real, preservando DI e Open/Closed para futuras implementações.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseRunnerStubs.cs†L1-L115】【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseRunnerStubs.cs†L117-L195】
- **Strategy Pattern preparado**: criada `IDefenseStrategy` com `PlanetDefenseSetupContext`, permitindo injeção de comportamentos diferentes (agressivo/defensivo) por planeta ou recurso, reforçando Dependency Inversion ao isolar decisões de spawn de implementações concretas. O contrato é neutro para multiplayer local e pode ser usado pelos runners ou orchestrators futuros.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/IDefenseStrategy.cs†L1-L43】

### Passo 3 — Sistema de Roles Explícitos
- **Provedores explícitos de role**: a heurística por string foi encapsulada atrás do contrato `IDefenseRoleProvider.GetDefenseRole()`. O `ActorMaster` é a fonte primária do papel defensivo, garantindo configuração por prefab/GameObject e reduzindo fragilidade em sessões multiplayer locais.【F:Assets/_ImmersiveGames/Scripts/DetectionsSystems/Core/DefenseRole.cs†L1-L19】【F:Assets/_ImmersiveGames/Scripts/PlayerControllerSystem/Detections/PlayerDetectionController.cs†L19-L98】【F:Assets/_ImmersiveGames/Scripts/EaterSystem/Detections/EaterDetectionController.cs†L11-L93】【F:Assets/_ImmersiveGames/Scripts/ActorSystems/ActorMaster.cs†L9-L114】
- **Resolução ordenada no controlador**: `PlanetDefenseController` resolve o papel na seguinte ordem: provedor no detector, provedor no Owner e configuração explícita via `DefenseRoleConfig`. Na ausência dessas fontes, retorna `Unknown`, incentivando configuração explícita e reduzindo fragilidade por nome em multiplayer local.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Detectable/PlanetDefenseController.cs†L97-L170】
- **Configuração por prefab/identificador**: `DefenseRoleConfig` (ScriptableObject opcional) permite mapear roles por identificador (ex.: `ActorName` ou nome de GameObject) de forma determinística, evitando colisões de nomes genéricos em multiplayer local. O controlador consulta o config antes de assumir `Unknown`, incentivando fonte única de verdade para papéis defensivos.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/DefenseRoleConfig.cs†L1-L49】

### 26/11/2025 — Integração de DefenseRole no ActorMaster
- **Papel configurável por ator**: `ActorMaster` agora expõe `DefenseRole` serializado e implementa `IDefenseRoleProvider`, permitindo definir o papel diretamente no prefab ou GameObject e tornando-o acessível para qualquer sistema que consuma `IActor` (sensores, controladores e estratégias).【F:Assets/_ImmersiveGames/Scripts/ActorSystems/ActorMaster.cs†L9-L114】【F:Assets/_ImmersiveGames/Scripts/ActorSystems/IActor.cs†L1-L25】
- **Detectores delegando ao ator**: `PlayerDetectionController` e `EaterDetectionController` deixam de implementar o contrato de role e delegam à hierarquia do ator, reduzindo duplicação e garantindo consistência entre sensores e outros componentes que derivam do mesmo `ActorMaster`. Isso mantém compatibilidade com o fallback legado de `PlanetDefenseController` sem dependência de heurísticas por nome no detector.【F:Assets/_ImmersiveGames/Scripts/PlayerControllerSystem/Detections/PlayerDetectionController.cs†L1-L178】【F:Assets/_ImmersiveGames/Scripts/EaterSystem/Detections/EaterDetectionController.cs†L1-L105】

### 26/11/2025 — Debug para Fontes de Resolução de Role
- **Telemetria de resolução**: `PlanetDefenseController.ResolveDefenseRole` registra logs verbosos diferenciando a fonte usada (provider do detector, provider do Owner, configuração via `DefenseRoleConfig`). Isso facilita verificar se os prefabs configurados estão sendo respeitados em multiplayer local e garante rastreabilidade durante a transição para providers explícitos.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Detectable/PlanetDefenseController.cs†L97-L170】
- **Dicas de teste**: habilite o nível Verbose no `DebugUtility` para ver mensagens de origem de role ao engajar/desengajar defesas. Valide cenas com múltiplos jogadores e inimigos para confirmar que o provider do `ActorMaster` é priorizado e que casos `Unknown` indicam falta de configuração.

### 26/11/2025 — Atualização de Debug para Fontes de Role
- **Logs por ponto de resolução**: os métodos `TryResolveFromDetector`, `TryResolveFromOwner` e `TryResolveFromConfig` agora emitem logs verbosos indicando exatamente qual fonte forneceu o `DefenseRole` (incluindo distinção entre provider direto e em componente). Isso simplifica a investigação em multiplayer local sobre qual entidade ou configuração atribuiu o papel.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Detectable/PlanetDefenseController.cs†L101-L173】
- **Dicas de teste**: mantenha o `DebugUtility` em nível Verbose e monitore mensagens "Nenhuma fonte resolveu o role; usando Unknown". Prefabs ou atores que ainda retornam `Unknown` devem receber configuração no `ActorMaster` ou atualização no `DefenseRoleConfig` para manter consistência.

### 26/11/2025 — Remoção de Fallback Legacy em ResolveDefenseRole
- **Fonte única e determinística**: `ResolveDefenseRole` agora confia apenas em providers explícitos (detector, Owner) e em `DefenseRoleConfig`. Caso nenhum forneça, retorna `Unknown`, incentivando a configuração correta em prefabs e atores e eliminando heurísticas por string sujeitas a conflito em multiplayer local.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Detectable/PlanetDefenseController.cs†L101-L150】
- **Monitoramento orientado a ação**: ao retornar `Unknown`, o controlador registra log verboso e recomenda adicionar providers/configs. Isso acelera a migração completa para roles explícitos, preservando clareza de diagnóstico durante testes locais.

### 26/11/2025 — Passo 4: Refatoração do Serviço de Spawn com Integração de PoolSystem e FrequencyTimer
- **Separação de responsabilidades**: o fluxo de spawn agora usa `DefenseStateManager` para rastrear detectores/planetas e `DefenseDebugLogger` para logs periódicos via `FrequencyTimer` por planeta (intervalo inteiro em segundos), removendo `Update`, corrotinas e reduzindo alocação de GC.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/DefenseStateManager.cs†L1-L78】【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/DefenseDebugLogger.cs†L1-L132】
- **Pools reais e ondas com timers**: os stubs foram substituídos por `RealPlanetDefensePoolRunner` (registrando pools no `PoolManager` com `PoolData` pré-configurado via Editor, sem criar `PoolData` em runtime) e `RealPlanetDefenseWaveRunner` (usa `FrequencyTimer` por planeta com intervalo em segundos, spawn via `ObjectPool` e evento `PlanetDefenseMinionSpawnedEvent`).【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/RealPlanetDefensePoolRunner.cs†L1-L94】【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/RealPlanetDefenseWaveRunner.cs†L1-L200】【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseEvents.cs†L1-L88】
- **Serviço orquestrador**: `PlanetDefenseSpawnService` injeta os runners reais, cria `PlanetDefenseSetupContext` com recurso do planeta/pool configurado, aquece pools, inicia/paralisa ondas conforme engajamento/disengajamento e limpa pools em disable, preservando logs verbosos e compatibilidade de eventos.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseSpawnService.cs†L1-L230】
- **Bootstrap e DI**: `DependencyBootstrapper` registra o `DefenseStateManager`, runners reais e o serviço de spawn como singletons de cena, garantindo injeção e ciclo de vida correto para multiplayer local.【F:Assets/_ImmersiveGames/Scripts/Utils/DependencySystems/DependencyBootstrapper.cs†L1-L143】

### 26/11/2025 — Registro Delayed no Awake com DefaultExecutionOrder
- **Prioridade de inicialização**: `PlanetDefenseSpawnService` agora possui `[DefaultExecutionOrder(-100)]`, garantindo que o `Awake` seja chamado antes de outros `MonoBehaviours` críticos (ex.: `ActorMaster`) e mantendo a configuração via Inspector intacta.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseSpawnService.cs†L1-L110】
- **Registro auto-gerenciado**: no `Awake`, o serviço se registra globalmente como `IPlanetDefenseActivationListener` (e variantes segmentadas) somente se ainda não houver instância global, evitando instanciamentos dinâmicos e respeitando o objeto presente na cena.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/PlanetDefenseSpawnService.cs†L20-L117】
- **Bootstrap enxuto**: o `DependencyBootstrapper` deixou de criar dinamicamente o serviço; basta adicionar o componente à cena (ou prefab) e ele se auto-registra, preservando referências de Inspector e evitando duplicatas em multiplayer local.【F:Assets/_ImmersiveGames/Scripts/Utils/DependencySystems/DependencyBootstrapper.cs†L1-L115】
- **Exemplo de uso**: coloque `PlanetDefenseSpawnService` em um objeto de cena com os `PoolData` desejados; ao iniciar a cena, ele registrará listeners globais antes dos demais sistemas e responderá aos eventos de defesa sem necessidade de criação via código.

### 26/11/2025 — Melhorias no DefenseRoleConfig
- **Tooltips guiados**: `DefenseRoleConfig` agora traz tooltips claros para o papel de fallback e para a lista de mapeamentos, além de descrições em cada binding (identifier e role) para reduzir erros de configuração ao mapear nomes de atores/detectores para `DefenseRole`.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/DefenseRoleConfig.cs†L9-L55】
- **Inspector com ajuda contextual**: editor customizado exibe uma caixa de ajuda explicando o uso do config como fallback quando não há providers, facilitando onboarding e padronizando o preenchimento em equipes multiplayer locais.【F:Assets/_ImmersiveGames/Scripts/PlanetSystems/Defense/DefenseRoleConfigEditor.cs†L1-L24】
