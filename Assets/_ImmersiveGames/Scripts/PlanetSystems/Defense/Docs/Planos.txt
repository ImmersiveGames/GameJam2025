Beleza, vamos organizar isso como um mini-projeto com passos pequenos, testáveis e com o mínimo de risco.

Vou montar um **roadmap bem detalhado**, mas **sem código ainda**. Depois, quando você disser “vamos pro Passo X”, aí sim eu devolvo os arquivos completos com as alterações.

---

## Visão geral do plano

A ideia é atacar os problemas em camadas, sem refazer tudo de uma vez:

1. **Camada estrutural básica**
   Corrigir o acoplamento com o `RealPlanetDefenseWaveRunner` (DIP) e garantir que o alvo primário é configurado via interface.

2. **Ciclo de estratégia de defesa (`IDefenseStrategy`)**
   Fazer a strategy de fato existir no fluxo (ConfigureContext / OnEngaged / OnDisengaged), mas ainda de forma opcional.

3. **Propagação de `DefenseRole` de ponta a ponta**
   Pegar o role descoberto no `PlanetDefenseController` e levá-lo até os minions.

4. **Eventos complementares (`PlanetDefenseMinionSpawnedEvent`)**
   Ligar o evento de minion spawnado para telemetria e efeitos externos.

5. **Listeners de ativação (ou remoção deles)**
   Decidir e implementar ou limpar `IPlanetDefenseActivationListener` e derivados.

6. **Telemetria e debug (uso de `EngagedAt` e afins)**
   Aproveitar o estado já existente para logs melhores.

7. **Passada final de limpeza e documentação**
   Revisar nomes, comentários e garantir que tudo novo está documentado.

Cada bloco acima vai ser dividido em **passos pequenos com teste claro**.

---

## Fase 0 – Base de teste e sanity check

### Passo 0.1 – Cenário padrão de teste manual

**Objetivo**
Definir um cenário padrão que você sempre pode usar depois de cada alteração.

**Sem alteração de código.**

**Cenário sugerido:**

* Um planeta com:

  * `PlanetsMaster` + `PlanetDefenseController` + `PlanetDefenseEventHandler`.
  * `PlanetDefenseLoadoutSo` já configurado com:

    * `PoolData` que referencia um prefab com `DefenseMinionPoolable` + `DefenseMinionController`.
    * `DefenseWaveProfileSo` com uma wave simples (ex.: 2–3 minions a cada X segundos).
* Um `EaterPrefab` com:

  * `AbstractDetector` + `PlanetDefenseDetector` (ou o sensor que você já tem).
* Logs que você já viu funcionando (GameManager, Compass, Detector, etc.).

**Teste esperado (atual):**

1. Entrar no play.
2. Aproximar o `EaterPrefab` do planeta.
3. Ver nos logs:

   * `Engaging defense for planet`…
   * Mensagens do `RealPlanetDefenseWaveRunner` criando wave.
   * Mensagens de minions entrando e perseguindo algo.
4. Afastar o `EaterPrefab`:

   * Ver log de desengajar defesa.

A cada passo das fases seguintes a gente vai **reusar este cenário** como teste rápido.

---

## Fase 1 – Corrigir DIP e alvo primário

### Passo 1.1 – Introduzir `ConfigurePrimaryTarget` na interface

**Tipo de mudança**

* **Alteração** em `IPlanetDefenseWaveRunner`.
* **Alteração** em `RealPlanetDefenseWaveRunner`.

**Arquivos envolvidos**

* `PlanetDefenseRunnerStubs.cs` (onde está a interface `IPlanetDefenseWaveRunner`).
* `RealPlanetDefenseWaveRunner.cs`.

**O que fazer**

1. **Alteração – Interface**

   * Mover a assinatura de `ConfigurePrimaryTarget(PlanetsMaster planet, Transform primaryTarget, string primaryTargetLabel)` para dentro da interface `IPlanetDefenseWaveRunner`.
     (A assinatura já existe na classe concreta, vamos apenas elevá-la ao contrato.)

2. **Alteração – Classe concreta**

   * Garantir que `RealPlanetDefenseWaveRunner` implementa o método de forma compatível com a interface (provavelmente já está igual, mas precisamos alinhar se a assinatura mudar de nome/params).

**Teste 1.1**

* Compilar o projeto.
* Não deve haver erro de interface não implementada.
* Comportamento em runtime deve permanecer idêntico (nenhuma mudança de lógica ainda).

---

### Passo 1.2 – Remover cast concreto no `PlanetDefenseSpawnService`

**Tipo de mudança**

* **Alteração** em `PlanetDefenseSpawnService`.

**Arquivo envolvido**

* `PlanetDefenseSpawnService.cs`.

**O que fazer**

1. **Alteração – HandleEngaged**

   * Substituir o trecho que faz:

     ```csharp
     if (_waveRunner is RealPlanetDefenseWaveRunner realRunner)
     {
         realRunner.ConfigurePrimaryTarget(...);
     }
     ```

   * Por uma chamada direta a `_waveRunner.ConfigurePrimaryTarget(...)`.

**Teste 1.2**

* Compilar.
* Rodar o cenário do Passo 0.1.
* Confirmar via log (`RealPlanetDefenseWaveRunner`) que o alvo primário continuo sendo setado (mesmos logs de antes, sem exceções).

Resultado da fase:
O serviço passa a depender **só da interface**, sem cast pra implementação concreta → melhora de DIP.

---

## Fase 2 – Tornar `IDefenseStrategy` realmente viva

Hoje a strategy existe, mas quase não é usada.

### Passo 2.1 – Decidir fonte da strategy (somente estrutura)

**Tipo de mudança**

* **Adição** de campo/membro para armazenar strategy por planeta.
* **Adição/Alteração** de criação de `PlanetDefenseSetupContext`.

**Arquivos envolvidos**

* `PlanetDefenseSpawnService.cs`.
* Opcionalmente `PlanetDefenseLoadoutSO.cs` ou outro lugar de configuração.

**O que fazer (sem inventar implementação concreta ainda)**

1. **Adição – Origem da strategy**
   Duas opções que vamos definir no código depois, mas já planejar no roadmap:

   * Opção A: adicionar um campo opcional em `PlanetDefenseLoadoutSO` do tipo `ScriptableObject` que implementa `IDefenseStrategy`.
   * Opção B: manter um registro em `PlanetDefenseSpawnService` (via métodos `SetStrategyForPlanet` ou similar).

   Neste momento, só estamos **planejando**; a implementação concreta da escolha fica para quando você disser “ok, vamos”.

2. **Alteração – `BuildContext`**

   * Garantir que quando montamos `PlanetDefenseSetupContext`, o campo `strategy` receba **alguma coisa real** (mesmo que seja `null` se nada configurado).
   * Struct já tem `IDefenseStrategy strategy`; vamos usar isso.

**Teste 2.1**

* Compilar (sem ainda criar strategy concreta).
* As defesas devem continuar funcionando exatamente igual (strategy ainda será `null` na prática).

---

### Passo 2.2 – Chamar `ConfigureContext` e `OnEngaged` da strategy

**Tipo de mudança**

* **Alteração** em `RealPlanetDefenseWaveRunner`.

**Arquivo envolvido**

* `RealPlanetDefenseWaveRunner.cs`.

**O que fazer**

1. **Alteração – Ao criar o `WaveLoop` em `StartWaves`**

   * Depois de resolver o `PlanetDefenseSetupContext`, chamar:

     * `strategy?.ConfigureContext(context);`
     * `strategy?.OnEngaged(planet, detectionType);`

2. **Alteração – `SpawnWave`**

   * A chamada `strategy?.OnEngaged(...)` que hoje ocorre dentro de `SpawnWave` pode ser reavaliada:

     * Ou mantemos como “OnWaveSpawned”.
     * Ou deixamos só no começo do ciclo na primeira wave.
   * Aqui, o roadmap é: **no primeiro momento apenas garantir que ConfigureContext e OnEngaged são chamados pelo menos uma vez no início**. Refinamentos podem vir depois.

**Teste 2.2**

* Compilar.
* Rodar Passo 0.1.
* Como ainda não teremos uma strategy concreta, não deve haver mudança de comportamento, apenas runtime com `strategy == null` sem exceções.

---

### Passo 2.3 – Implementar uma strategy simples para teste

**Tipo de mudança**

* **Adição** de uma classe que implementa `IDefenseStrategy`.

**Arquivo novo**

* Ex.: `DefaultAggressiveDefenseStrategy.cs` (nome a definir quando formos escrever).

**O que fazer**

1. **Adição – Classe concreta**

   * Implementar `IDefenseStrategy` com:

     * `StrategyId` fixo (ex.: `"DefaultAggressive"`).
     * `TargetRole` definido (ex.: `DefenseRole.Eater` ou similar).
     * `ConfigureContext` apenas logando contexto.
     * `OnEngaged` e `OnDisengaged` apenas logando chamadas.

2. **Alteração – Configuração**

   * Em algum planeta de teste, configurar essa strategy como ativa (depende da decisão do Passo 2.1: via Loadout, via Service, etc.).

**Teste 2.3**

* Rodar o cenário.
* Ver logs da strategy sendo chamada:

  * `ConfigureContext` na primeira vez.
  * `OnEngaged` na ativação.
  * `OnDisengaged` quando o último detector sai.

Agora o sistema de strategies está **vivo**, ainda que simples.

---

## Fase 3 – Propagação do `DefenseRole` até os minions

Aqui a gente fecha o “loop” de role.

### Passo 3.1 – Estender o evento de engajamento com role

**Tipo de mudança**

* **Alteração** em `PlanetDefenseEngagedEvent`.

**Arquivo envolvido**

* `PlanetDefenseEvents.cs`.

**O que fazer**

1. **Alteração – Struct**

   * Adicionar um campo `DefenseRole TargetRole` (por exemplo) ao `PlanetDefenseEngagedEvent`.
   * Ajustar o construtor (se existir) para receber esse novo campo.

**Teste 3.1**

* Compilar (vai quebrar em todos os lugares que criam esse evento).
* Ajustar o código nos passos seguintes.

---

### Passo 3.2 – Preencher role no `PlanetDefenseController`

**Tipo de mudança**

* **Alteração** em `PlanetDefenseController`.

**Arquivo envolvido**

* `PlanetDefenseController.cs`.

**O que fazer**

1. **Alteração – `EngageDefense`**

   * Após calcular `DefenseRole` via `ResolveDefenseRole(detector)`, usar esse valor para popular o novo campo `TargetRole` ao criar o `PlanetDefenseEngagedEvent`.

2. (Opcional) **Alteração – `DisengageDefense`**

   * Se for interessante, você pode também repassar o role no evento de disengage (se decidir adicionar o campo também no `PlanetDefenseDisengagedEvent`).

**Teste 3.2**

* Compilar.
* Rodar cenário.
* Logs do `PlanetDefenseController` devem mostrar exatamente o mesmo comportamento, mas agora o event carrega role.

---

### Passo 3.3 – Levar o role até o WaveRunner/Minion

**Tipo de mudança**

* **Alteração** em `PlanetDefenseSpawnService`.
* **Alteração** em `RealPlanetDefenseWaveRunner`.

**Arquivos envolvidos**

* `PlanetDefenseSpawnService.cs`.
* `RealPlanetDefenseWaveRunner.cs`.

**O que fazer**

1. **Alteração – Service**

   * Em `HandleEngaged`, além de passar `targetTransform` e `targetLabel` para `_waveRunner.ConfigurePrimaryTarget`, precisamos:

     * Ou estender `ConfigurePrimaryTarget` para também receber `DefenseRole`.
     * Ou armazenar o role no `PlanetDefenseSetupContext`/`WaveLoop`.

   **Aqui no roadmap**: vamos planejar a opção mais limpa – **estender `ConfigurePrimaryTarget`** na interface e implementação para receber o `DefenseRole` também. (Quando formos escrever o código, fazemos isso com cuidado.)

2. **Alteração – WaveRunner**

   * Guardar o `DefenseRole` no `WaveLoop` para usar depois em `SpawnWave`.

3. **Alteração – Minion**

   * Em `SpawnWave`, quando chamar `controller.ConfigureTarget(...)`:

     * Usar o `DefenseRole` vindo do loop ao invés de `DefenseRole.Unknown`.

**Teste 3.3**

* Compilar.
* Rodar cenário.
* Colocar um breakpoint/log em `DefenseMinionController.ConfigureTarget` para verificar:

  * Se está recebendo o role diferente de `Unknown`.
* Se existir `DefenseRoleConfig`, confirmar que `ResolveRoleFromLabel` só será fallback (role vindo direto deve ser respeitado).

Resultado dessa fase:
O role calculado no controller chega até o minion.

---

## Fase 4 – Ligar `PlanetDefenseMinionSpawnedEvent`

### Passo 4.1 – Publicar evento ao spawnar cada minion

**Tipo de mudança**

* **Alteração** em `RealPlanetDefenseWaveRunner`.

**Arquivo envolvido**

* `RealPlanetDefenseWaveRunner.cs`.

**O que fazer**

1. **Alteração – `SpawnWave`**

   * Depois de configurar o `DefenseMinionController` com `ConfigureTarget` + `BeginEntryPhase`, publicar `PlanetDefenseMinionSpawnedEvent` no seu `EventBus`, preenchendo:

     * Planeta.
     * Tipo de detecção.
     * Talvez referência ao minion, se o struct permitir (não vamos inventar campos; só usar o que já existe).

**Teste 4.1**

* Adicionar temporariamente um assinante simples para esse evento (pode ser um `MonoBehaviour` só de log).
* Rodar cenário e verificar que:

  * Para cada minion spawnado, o evento é emitido e logado.

---

## Fase 5 – Listeners de ativação

Aqui temos duas direções, e o roadmap pode respeitar isso como um “fork”.

### Passo 5.1 – Decidir destino dos listeners

**Sem alteração de código ainda.**

* Opção A: **Remover** `IDefenseEngagedListener`, `IDefenseDisengagedListener`, `IDefenseDisabledListener` e `IPlanetDefenseActivationListener` para simplificar.
* Opção B: **Implementar** pelo menos um listener real (por exemplo, para UI) e fazer o `PlanetDefenseEventHandler` repassar os eventos para todos os listeners registrados.

Quando chegarmos nesse passo, você decide o rumo. O restante do roadmap não depende deles.

---

## Fase 6 – Telemetria e Debug (`EngagedAt` e companhia)

### Passo 6.1 – Usar `EngagedAt` no `DefenseDebugLogger`

**Tipo de mudança**

* **Alteração** em `DefenseDebugLogger`.

**Arquivo envolvido**

* `DefenseDebugLogger.cs`.

**O que fazer**

1. **Alteração – Atualizar logs de loop**

   * Sempre que logar o estado da defesa, incluir:

     * Tempo desde engajamento: `Time.time - defenseState.EngagedAt`.

2. **Alteração – Opcional**

   * Adicionar contadores simples (total de waves spawnadas, total de minions spawnados no planeta, etc.) usando informações já disponíveis, para enriquecer log.

**Teste 6.1**

* Rodar cenário.
* Observar nos logs a duração da defesa em segundos e qualquer contagem adicionada.

---

## Fase 7 – Limpeza final e documentação

### Passo 7.1 – Revisão de comentários e nomes

**Tipo de mudança**

* **Alteração** de comentários (XML docs e comentários comuns).
* **Alteração leve** de nomes se houver incoerências.

**Arquivos envolvidos**

* Todos os principais: `PlanetDefenseController`, `PlanetDefenseSpawnService`, `RealPlanetDefenseWaveRunner`, `RealPlanetDefensePoolRunner`, `DefenseMinionController`, etc.

**O que fazer**

1. **Atualizar comentários** para refletir:

   * Que strategy está ativa de verdade.
   * Que roles são propagados.
   * Que o minion spawned event é usado.
   * Que o wave runner agora é configurado via interface.

2. **Revisar nomes** apenas onde forem claramente enganosos.

**Teste 7.1**

* Apenas garantir compilação e leitura do código mais clara.
* Nenhuma mudança de comportamento prevista aqui.

---

## Como seguir a partir daqui

Quando você quiser começar, podemos fazer assim:

1. Você escolhe: “vamos pro **Passo 1.1**”.
2. Eu te devolvo:

   * Os arquivos **completos** afetados (por ex.: `PlanetDefenseRunnerStubs.cs` e `RealPlanetDefenseWaveRunner.cs`),
   * Com as mudanças claramente marcadas como:

     * `// ALTERAÇÃO`, `// ADIÇÃO`, `// REMOÇÃO` em comentários.
3. Você testa no Unity conforme o teste daquele passo.
4. Se tudo ok, avançamos para o passo seguinte.

Se quiser, já começamos direto pelo **Passo 1.1** na próxima mensagem.
