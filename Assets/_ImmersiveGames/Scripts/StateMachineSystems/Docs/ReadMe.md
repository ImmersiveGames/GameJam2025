# üîÅ State Machine Systems ‚Äî Documenta√ß√£o Oficial (v2.0)

## üìö √çndice
1. [Vis√£o Geral](#vis√£o-geral)
2. [Arquitetura Dirigida a Eventos](#arquitetura-dirigida-a-eventos)
3. [Estados do Ciclo de Jogo](#estados-do-ciclo-de-jogo)
4. [Fluxo de Eventos](#fluxo-de-eventos)
5. [Integra√ß√£o com UI e Controles](#integra√ß√£o-com-ui-e-controles)
    1. [Usando `GameLoopRequestButton`](#usando-gamelooprequestbutton)
    2. [Criando Bot√µes Personalizados](#criando-bot√µes-personalizados)
6. [Ferramentas de Teste no Editor](#ferramentas-de-teste-no-editor)
7. [Boas Pr√°ticas](#boas-pr√°ticas)

---

## Vis√£o Geral
A infraestrutura de FSM (`StateMachineSystems`) controla o ciclo completo do jogo multiplayer local. Ela segue princ√≠pios SOLID, desacoplados via `EventBus`, permitindo que UI, controles f√≠sicos ou automa√ß√µes de QA disparem o fluxo sem depender de `Input` direto.

Componentes principais:
- `GameManagerStateMachine`: orquestra transi√ß√µes entre estados.
- Estados concretos (`MenuState`, `PlayingState`, `PausedState`, `GameOverState`, `VictoryState`), cada um respons√°vel apenas por suas a√ß√µes.
- `StateMachine` gen√©rica e `StateMachineBuilder`: infraestrutura reutiliz√°vel para qualquer FSM do projeto.
- `GameManager`: ponto de entrada que escuta pedidos e publica eventos efetivos (start/pause/resume/reset/game over/victory).

---

## Arquitetura Dirigida a Eventos

```
UI / Controles ‚Üí GameLoopRequestEvent (EventBus)
                             ‚Üì
                GameManagerStateMachine
                             ‚Üì
                     GameManager valida
                             ‚Üì
        Eventos efetivos (Start, Pause, Victory, ...)
                             ‚Üì
                    Estados reagem e propagam
```

1. UI ou outros sistemas disparam *pedidos* (`GameStartRequestedEvent`, `GameResetRequestedEvent`, etc.).
2. `GameManagerStateMachine` converte pedidos em transi√ß√µes internas usando `EventTriggeredPredicate`.
3. `GameManager` verifica se o pedido √© v√°lido para o estado atual antes de publicar o evento definitivo (`GamePauseEvent`, `GameStartEvent`, `GameOverEvent`, `GameVictoryEvent`).
4. Estados concretos executam l√≥gica de entrada/sa√≠da (UI, time scale, etc.) e notificam demais servi√ßos.

Essa separa√ß√£o garante que qualquer camada (UI, IA, automa√ß√£o) possa pilotar o loop sem conhecer implementa√ß√µes internas.

---

## Estados do Ciclo de Jogo

| Estado | Ativo? | Eventos recebidos | Eventos emitidos |
| ------ | ------ | ----------------- | ---------------- |
| `MenuState` | ‚ùå | `GameStartRequestedEvent`, `GameResetRequestedEvent` | `StateChangedEvent(false)` |
| `PlayingState` | ‚úÖ | `GamePauseRequestedEvent`, `GameOverEvent`, `GameVictoryEvent`, `GameResetRequestedEvent` | `GamePauseEvent(false)`, `StateChangedEvent(true)` |
| `PausedState` | ‚ùå | `GameResumeRequestedEvent`, `GameResetRequestedEvent` | `GamePauseEvent(true)` |
| `GameOverState` | ‚ùå | `GameResetRequestedEvent` | `StateChangedEvent(false)` |
| `VictoryState` | ‚ùå | `GameResetRequestedEvent` | `StateChangedEvent(false)` |

Todos os estados partilham a base `GameStateBase`, respons√°vel por avisar UI e servi√ßos dependentes quando entram ou saem.

---

## Fluxo de Eventos

Eventos dispon√≠veis no `GameEventsBus`:

- **Pedidos** (usados para UI/controles):
  - `GameStartRequestedEvent`
  - `GamePauseRequestedEvent`
  - `GameResumeRequestedEvent`
  - `GameResetRequestedEvent`

- **Eventos efetivos** (disparados pelo `GameManager` depois de validar o pedido):
  - `GameStartEvent`
  - `GamePauseEvent`
  - `GameOverEvent`
  - `GameVictoryEvent`

- **Notifica√ß√µes auxiliares**:
  - `StateChangedEvent` (indica se o jogo est√° ativo).
  - Eventos de atores (`ActorDeathEvent`, `ActorReviveEvent`, `ActorStateChangedEvent`).

### Ordem t√≠pica para iniciar uma partida
1. UI dispara `GameStartRequestedEvent`.
2. `GameManagerStateMachine` muda de `MenuState` ‚Üí `PlayingState`.
3. `GameManager` publica `GameStartEvent` para iniciar gameplay.
4. Subscritores (`SpawnSystems`, `TimerSystem`, etc.) respondem ao `GameStartEvent`.

### Ordem t√≠pica para resetar
1. UI ou QA dispara `GameResetRequestedEvent` (ou via menu de contexto).
2. FSM retorna para `MenuState` e executa `Rebuild` via `GameManager.ResetGame`.
3. Cena √© recarregada e estados voltam ao padr√£o.

---

## Integra√ß√£o com UI e Controles

Voc√™ pode conectar qualquer fonte de input (bot√µes, atalhos, rede) apenas disparando os eventos de pedido. Abaixo, duas abordagens.

### Usando `GameLoopRequestButton`
1. Adicione o componente `GameLoopRequestButton` (menu *Immersive Games/Game Loop/Game Loop Request Button*) ao mesmo objeto que j√° possui um `Button` da UI.
2. No inspetor, escolha o `requestType` desejado:
   - `Start`, `Pause`, `Resume`, `Reset`, `GameOver`, `Victory`.
3. No `Button.onClick`, referencie o pr√≥prio componente e a fun√ß√£o `GameLoopRequestButton.RaiseRequest`.

```csharp
// Internamente, o componente dispara o evento correspondente:
EventBus<GameStartRequestedEvent>.Raise(new GameStartRequestedEvent());
```

Esse componente √© ideal para prototipagem e telas de debug, evitando boilerplate.

### Criando Bot√µes Personalizados
Se preferir um script dedicado, basta publicar os eventos manualmente:

```csharp
using _ImmersiveGames.Scripts.GameManagerSystems.Events;
using _ImmersiveGames.Scripts.Utils.BusEventSystems;
using UnityEngine;

public sealed class CustomStartButton : MonoBehaviour
{
    // Chamado por UI Button ‚Üí OnClick
    public void RequestStart()
    {
        // Coment√°rio em portugu√™s: dispara pedido de in√≠cio seguindo o padr√£o event-driven.
        EventBus<GameStartRequestedEvent>.Raise(new GameStartRequestedEvent());
    }
}
```

O mesmo padr√£o vale para reset (`GameResetRequestedEvent`), pausa/retomada (`GamePauseRequestedEvent`, `GameResumeRequestedEvent`), ou testes de fim de jogo (`GameOverEvent`, `GameVictoryEvent`).

---

## Ferramentas de Teste no Editor

O `GameManager` exp√µe menus de contexto para acelerar QA e depura√ß√£o:

- **Game Loop/Request Start** ‚Äî envia `GameStartRequestedEvent`.
- **Game Loop/Request Pause** ‚Äî envia `GamePauseRequestedEvent`.
- **Game Loop/Request Resume** ‚Äî envia `GameResumeRequestedEvent`.
- **Game Loop/Request Reset** ‚Äî envia `GameResetRequestedEvent` (executa rebuild + recarrega cena).
- **Game Loop/Force Game Over** ‚Äî publica `GameOverEvent` diretamente.
- **Game Loop/Force Victory** ‚Äî publica `GameVictoryEvent` diretamente.

Acesse clicando no √≠cone ‚ò∞ do componente `GameManager` no inspetor e selecione a a√ß√£o desejada. Todos os comandos reutilizam o pipeline de eventos existente, garantindo que os mesmos guardrails sejam exercitados.

---

## Boas Pr√°ticas

- **Dispare pedidos, n√£o estados**: UI deve enviar `*RequestedEvent` para permitir que `GameManager` valide a transi√ß√£o.
- **Evite depend√™ncia direta de `GameManagerStateMachine`**: sempre use o `EventBus`.
- **Desinscreva bindings**: quando adicionar novos servi√ßos que escutam eventos, use `EventBinding` e limpe-os em `OnDestroy`.
- **Testes automatizados**: para simular fluxo no editor, use `ContextMenu` ou scripts de editor que chamem `RaiseRequest`.
- **Extens√£o de estados**: ao adicionar novos estados, registre-os no `StateMachineBuilder` e exponha novos eventos de pedido/efetiva√ß√£o conforme necess√°rio.

---

> Qualquer d√∫vida ou nova feature no ciclo de jogo, atualizar este documento mantendo o padr√£o de exemplos em ingl√™s e coment√°rios em portugu√™s.
